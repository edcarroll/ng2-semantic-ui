{"version":3,"file":"popup.js","sourceRoot":"","sources":["../../../../src/modules/popup/components/popup.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ViewChild, ViewContainerRef, ElementRef, EventEmitter, HostListener, HostBinding } from \"@angular/core\";\nimport { PositioningService, IDynamicClasses } from \"../../../misc/util/index\";\nimport { TransitionController, TransitionDirection, Transition } from \"../../transition/index\";\nimport { IPopup } from \"../classes/popup-controller\";\nimport { TemplatePopupConfig } from \"../classes/popup-template-controller\";\n\n@Component({\n    selector: \"sui-popup\",\n    template: `\n<div class=\"ui popup\"\n     [ngClass]=\"dynamicClasses\"\n     [suiTransition]=\"transitionController\"\n     [attr.direction]=\"direction\"\n     #container>\n\n    <ng-container *ngIf=\"!config.template && (!!config.header || !!config.text)\">\n        <div class=\"header\" *ngIf=\"config.header\">{{ config.header }}</div>\n        <div class=\"content\">{{ config.text }}</div>\n    </ng-container>\n    <div #templateSibling></div>\n\n    <sui-popup-arrow *ngIf=\"!config.isBasic\"\n                     [placement]=\"positioningService.actualPlacement\"\n                     [inverted]=\"config.isInverted\"></sui-popup-arrow>\n</div>\n`,\n    styles: [`\n.ui.popup {\n    /* Autofit popup to the contents. */\n    right: auto;\n}\n\n.ui.animating.popup {\n    /* When the popup is animating, it may not initially be in the correct position.\n       This fires a mouse event, causing the anchor's mouseleave to fire - making the popup flicker.\n       Setting pointer-events to none while animating fixes this bug. */\n    pointer-events: none;\n}\n\n.ui.popup::before {\n    /* Hide the Semantic UI CSS arrow. */\n    display: none;\n}\n\n/* Offset popup by 0.75em above and below when placed 'vertically'. */\n.ui.popup[direction=\"top\"],\n.ui.popup[direction=\"bottom\"] {\n    margin-top: 0.75em;\n    margin-bottom: 0.75em;\n}\n\n/* Offset popup by 0.75em either side when placed 'horizontally'. */\n.ui.popup[direction=\"left\"],\n.ui.popup[direction=\"right\"] {\n    margin-left: 0.75em;\n    margin-right: 0.75em;\n}\n`]\n})\nexport class SuiPopup implements IPopup {\n    // Config settings for this popup.\n    public config:TemplatePopupConfig<any>;\n\n    public transitionController:TransitionController;\n    public positioningService:PositioningService;\n\n    // Keeps track of whether the popup is open internally.\n    private _isOpen:boolean;\n    // `setTimeout` timer pointer for cancelling popup close.\n    public closingTimeout:number;\n\n    // Fires when the popup opens (and the animation is completed).\n    public onOpen:EventEmitter<void>;\n    // Fires when the popup closes (and the animation is completed).\n    public onClose:EventEmitter<void>;\n\n    public get isOpen():boolean {\n        return this._isOpen;\n    }\n\n    // `ElementRef` for the positioning subject.\n    @ViewChild(\"container\", { read: ViewContainerRef })\n    private _container:ViewContainerRef;\n\n    public set anchor(anchor:ElementRef) {\n        // Whenever the anchor is set (which is when the popup is created), recreate the positioning service with the appropriate options.\n        this.positioningService = new PositioningService(anchor, this._container.element, this.config.placement, \".dynamic.arrow\");\n    }\n\n    // Returns the direction (`top`, `left`, `right`, `bottom`) of the current placement.\n    public get direction():string | undefined {\n        if (this.positioningService) {\n            return this.positioningService.actualPlacement.split(\" \").shift();\n        }\n    }\n\n    // Returns the alignment (`top`, `left`, `right`, `bottom`) of the current placement.\n    public get alignment():string | undefined {\n        if (this.positioningService) {\n            return this.positioningService.actualPlacement.split(\" \").pop();\n        }\n    }\n\n    public get dynamicClasses():IDynamicClasses {\n        const classes:IDynamicClasses = {};\n        if (this.direction) {\n            classes[this.direction] = true;\n        }\n        if (this.alignment) {\n            classes[this.alignment] = true;\n        }\n        if (this.config.isInverted) {\n            classes.inverted = true;\n        }\n        if (this.config.isBasic) {\n            classes.basic = true;\n        }\n        return classes;\n    }\n\n    // `ViewContainerRef` for the element the template gets injected as a sibling of.\n    @ViewChild(\"templateSibling\", { read: ViewContainerRef })\n    public templateSibling:ViewContainerRef;\n\n    @HostBinding(\"attr.tabindex\")\n    private _tabindex:number;\n\n    constructor(public elementRef:ElementRef) {\n        this.transitionController = new TransitionController(false);\n\n        this._isOpen = false;\n\n        this.onOpen = new EventEmitter<void>();\n        this.onClose = new EventEmitter<void>();\n\n        this._tabindex = 0;\n    }\n\n    public open():void {\n        // Only attempt to open if currently closed.\n        if (!this.isOpen) {\n            // Cancel the closing timer.\n            clearTimeout(this.closingTimeout);\n\n            // Cancel all other transitions, and initiate the opening transition.\n            this.transitionController.stopAll();\n            this.transitionController.animate(\n                new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.In, () => {\n                    // Focus any element with [autofocus] attribute.\n                    const autoFocus = this.elementRef.nativeElement.querySelector(\"[autofocus]\") as HTMLElement | null;\n                    if (autoFocus) {\n                        // Autofocus after the browser has had time to process other event handlers.\n                        setTimeout(() => autoFocus.focus(), 10);\n                        // Try to focus again when the modal has opened so that autofocus works in IE11.\n                        setTimeout(() => autoFocus.focus(), this.config.transitionDuration);\n                    }\n                }));\n\n            // Refresh the popup position after a brief delay to allow for browser processing time.\n            this.positioningService.placement = this.config.placement;\n            setTimeout(() => this.positioningService.update());\n\n            // Finally, set the popup to be open.\n            this._isOpen = true;\n            this.onOpen.emit();\n        }\n    }\n\n    public toggle():void {\n        if (!this.isOpen) {\n            return this.open();\n        }\n\n        return this.close();\n    }\n\n    public close():void {\n        // Only attempt to close if currently open.\n        if (this.isOpen) {\n            // Cancel all other transitions, and initiate the closing transition.\n            this.transitionController.stopAll();\n            this.transitionController.animate(\n                new Transition(this.config.transition, this.config.transitionDuration, TransitionDirection.Out));\n\n            // Cancel the closing timer.\n            clearTimeout(this.closingTimeout);\n            // Start the closing timer, that fires the `onClose` event after the transition duration number of milliseconds.\n            this.closingTimeout = window.setTimeout(() => this.onClose.emit(), this.config.transitionDuration);\n\n            // Finally, set the popup to be closed.\n            this._isOpen = false;\n        }\n    }\n\n    @HostListener(\"click\", [\"$event\"])\n    public onClick(event:MouseEvent):void {\n        // Makes sense here, as the popup shouldn't be attached to any DOM element.\n        event.stopPropagation();\n    }\n}\n"]}