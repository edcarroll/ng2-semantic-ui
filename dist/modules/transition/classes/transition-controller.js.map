{"version":3,"file":"transition-controller.js","sourceRoot":"","sources":["../../../../src/modules/transition/classes/transition-controller.ts"],"names":[],"mappings":"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","sourcesContent":["import { Renderer2, ElementRef, ChangeDetectorRef } from \"@angular/core\";\nimport { Transition, TransitionDirection } from \"./transition\";\n\nexport class TransitionController {\n    private _renderer:Renderer2;\n\n    private _element:ElementRef;\n\n    private _changeDetector:ChangeDetectorRef;\n\n    // Used to delay animations until we have an element to animate.\n    private get _isReady():boolean {\n        return this._renderer != undefined && this._element != undefined && this._changeDetector != undefined;\n    }\n\n    // Sets the 'display' style when visible.\n    private _display:string;\n\n    // Stores queued transitions.\n    private _queue:Transition[];\n\n    private _isAnimating:boolean;\n\n    public get isAnimating():boolean {\n        return this._isAnimating;\n    }\n\n    // Set when the element is visible, and while it is transitioning out.\n    private _isVisible:boolean;\n\n    public get isVisible():boolean {\n        return this._isVisible;\n    }\n\n    // Set when the element is hidden, and not while it is transitioning.\n    private _isHidden:boolean;\n\n    public get isHidden():boolean {\n        return this._isHidden;\n    }\n\n    // Gets the first transition in the queue.\n    private get _queueFirst():Transition {\n        return this._queue[0];\n    }\n\n    // Gets the last transition in the queue.\n    private get _queueLast():Transition {\n        return this._queue[this._queue.length - 1];\n    }\n\n    // Stores the setTimeout pointer for cancelling the animation callback.\n    private _animationTimeout:number;\n\n    constructor(isInitiallyVisible:boolean = true, display:string = \"block\") {\n        // isInitiallyVisible sets whether the element starts out visible.\n        this._isVisible = isInitiallyVisible;\n        this._isHidden = !this._isVisible;\n\n        this._display = display;\n        this._queue = [];\n\n        this._isAnimating = false;\n    }\n\n    // Sets the renderer to be used for animating.\n    public registerRenderer(renderer:Renderer2):void {\n        this._renderer = renderer;\n        this.performTransition();\n    }\n\n    // Sets the element to perform the animations on.\n    public registerElement(element:ElementRef):void {\n        this._element = element;\n        this.performTransition();\n    }\n\n    // Sets the change detector to detect changes when using ChangeDetectionStrategy.OnPush.\n    public registerChangeDetector(changeDetector:ChangeDetectorRef):void {\n        this._changeDetector = changeDetector;\n        this.performTransition();\n    }\n\n    public animate(transition:Transition):void {\n        // Test if transition is one of the list that doesn't change the visible state.\n        // Should these eventually become classes?\n        const isDirectionless = [\"jiggle\", \"flash\", \"shake\", \"pulse\", \"tada\", \"bounce\"].indexOf(transition.type) !== -1;\n        if (isDirectionless) {\n            transition.direction = TransitionDirection.Static;\n        } else if (transition.direction == undefined || transition.direction === TransitionDirection.Either) {\n            // Set the direction to the opposite of the current visible state automatically if not set, or set to either direction.\n            transition.direction = this._isVisible ? TransitionDirection.Out : TransitionDirection.In;\n            if (this._queueLast) {\n                // If there is an transition in the queue already, set the direction to the opposite of the direction of that transition.\n                if (this._queueLast.direction === TransitionDirection.In) {\n                    transition.direction = TransitionDirection.Out;\n                } else if (this._queueLast.direction === TransitionDirection.Out) {\n                    transition.direction = TransitionDirection.In;\n                }\n            }\n        }\n\n        // Store the transition in the queue before attempting to perform it.\n        this._queue.push(transition);\n\n        this.performTransition();\n    }\n\n    private performTransition():void {\n        if (!this._isReady || this._isAnimating || !this._queueFirst) {\n            // Don't transition until we are ready, or if we are animating, or if there aren't any transitions in the queue.\n            return;\n        }\n\n        this._isAnimating = true;\n\n        const transition = this._queueFirst;\n\n        // Set the Semantic UI classes for transitioning.\n        transition.classes.forEach(c => this._renderer.addClass(this._element, c));\n        this._renderer.addClass(this._element, `animating`);\n        this._renderer.addClass(this._element, transition.directionClass);\n\n        // Set the Semantic UI styles for transitioning.\n        this._renderer.setStyle(this._element, `animationDuration`, `${transition.duration}ms`);\n        this._renderer.setStyle(this._element, `display`, this._display);\n\n        if (transition.direction === TransitionDirection.In) {\n            // Unset hidden if we are transitioning in.\n            this._isHidden = false;\n        }\n\n        // Wait the length of the animation before calling the complete callback.\n        this._animationTimeout = window.setTimeout(() => this.finishTransition(transition), transition.duration);\n    }\n\n    // Called when a transition has completed.\n    private finishTransition(transition:Transition):void {\n        // Unset the Semantic UI classes & styles for transitioning.\n        transition.classes.forEach(c => this._renderer.removeClass(this._element, c));\n        this._renderer.removeClass(this._element, `animating`);\n        this._renderer.removeClass(this._element, transition.directionClass);\n\n        this._renderer.removeStyle(this._element, `animationDuration`);\n        this._renderer.removeStyle(this._element, `display`);\n\n        if (transition.direction === TransitionDirection.In) {\n            // If we have just animated in, we are now visible.\n            this._isVisible = true;\n        } else if (transition.direction === TransitionDirection.Out) {\n            // If we have transitioned out, we should be invisible and hidden.\n            this._isVisible = false;\n            this._isHidden = true;\n        }\n\n        if (transition.onComplete) {\n            // Call the user-defined transition callback.\n            transition.onComplete();\n        }\n\n        // Delete the transition from the queue.\n        this._queue.shift();\n        this._isAnimating = false;\n\n        this._changeDetector.markForCheck();\n\n        // Immediately attempt to perform another transition.\n        this.performTransition();\n    }\n\n    // Stops the current transition, leaves the rest of the queue intact.\n    public stop(transition:Transition = this._queueFirst):void {\n        if (!transition || !this._isAnimating) {\n            return;\n        }\n\n        clearTimeout(this._animationTimeout);\n        this.finishTransition(transition);\n    }\n\n    // Stops the current transition, and empties the queue.\n    public stopAll():void {\n        this.clearQueue();\n        this.stop();\n    }\n\n    // Empties the transition queue but carries on with the current transition.\n    public clearQueue():void {\n        if (this.isAnimating) {\n            this._queue = [this._queueFirst];\n            return;\n        }\n        this._queue = [];\n    }\n}\n"]}