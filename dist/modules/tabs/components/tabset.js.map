{"version":3,"file":"tabset.js","sourceRoot":"","sources":["../../../../src/modules/tabs/components/tabset.ts"],"names":[],"mappings":"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","sourcesContent":["import { Component, ContentChildren, QueryList, AfterContentInit } from \"@angular/core\";\nimport { SuiTabHeader } from \"../directives/tab-header\";\nimport { SuiTabContent } from \"../directives/tab-content\";\nimport { Tab } from \"../classes/tab\";\n\n@Component({\n    selector: \"sui-tabset\",\n    template: `<ng-content></ng-content>`\n})\nexport class SuiTabset implements AfterContentInit {\n    @ContentChildren(SuiTabHeader)\n    private _tabHeaders:QueryList<SuiTabHeader>;\n\n    @ContentChildren(SuiTabContent)\n    private _tabContents:QueryList<SuiTabContent>;\n\n    // List of all tabs in the tabset.\n    public tabs:Tab[];\n\n    // Keeps track of the currently active tab.\n    private _activeTab:Tab;\n\n    public get activeTab():Tab {\n        return this._activeTab;\n    }\n\n    // When setting a tab as the currently active tab, it automatically gains\n    // `isActive` status (saves littering `isActive = true` everywhere).\n    public set activeTab(tab:Tab) {\n        this._activeTab = tab;\n        tab.isActive = true;\n    }\n\n    // Keeps track of the number of times `internalComponentsUpdated` is called.\n    private _barrierCount:number;\n\n    constructor() {\n        this.tabs = [];\n        this._barrierCount = 0;\n    }\n\n    public ngAfterContentInit():void {\n        // Fire `internalComponentsUpdated` when the query lists change.\n        this._tabHeaders.changes.subscribe(() => this.internalComponentsUpdated());\n        this._tabContents.changes.subscribe(() => this.internalComponentsUpdated());\n\n        // Initially load the tabs.\n        this.loadTabs();\n    }\n\n    // Fires whenever either the tab headers or tab contents query lists update.\n    private internalComponentsUpdated():void {\n        // We are using a 'counting barrier of n = 2', i.e. the code within only runs after the method is called twice.\n        // This is so that both the headers and contents query lists can update before we run code that matches the two up.\n        this._barrierCount++;\n\n        if (this._barrierCount === 2) {\n            // Reset the barrier so it can be called again.\n            this._barrierCount = 0;\n\n            // Update the tabs.\n            this.loadTabs();\n        }\n    }\n\n    // Connects tab headers to tab contents, and creates a tab instance for each pairing.\n    private loadTabs():void {\n        // Remove any tabs that no longer have an associated header.\n        this.tabs = this.tabs.filter(t => !!this._tabHeaders.find(tH => tH === t.header));\n\n        this._tabHeaders\n            // Filter out the loaded headers with attached tab instances.\n            .filter(tH => !this.tabs.find(t => t.header === tH))\n            .forEach(tH => {\n                const content = this._tabContents.find(tC => tC.id === tH.id);\n\n                if (!content) {\n                    // Error if an associated tab content cannot be found for the given header.\n                    throw new Error(\"A [suiTabHeader] must have a related [suiTabContent].\");\n                }\n\n                // Create a new tab instance for this header & content combo.\n                const tab = new Tab(tH, content);\n\n                // Subscribe to any external changes in the tab header's active state. External changes are triggered by user input.\n                tab.header.isActiveExternalChange.subscribe(() => this.onHeaderActiveChanged(tab));\n\n                // Add the new instance to the list of tabs.\n                this.tabs.push(tab);\n            });\n\n        // Assign each tab an index (which denotes the order they physically appear in).\n        this._tabHeaders\n            .forEach((tH, i) => {\n                const tab = this.tabs.find(t => t.header === tH);\n                if (tab) {\n                    tab.index = i;\n                }\n            });\n\n        // Sort the tabs by their index.\n        this.tabs.sort((a, b) => a.index - b.index);\n\n\n        if (!this.activeTab) { // Check if there are no current existing active tabs.\n            // If so, we must activate the first available tab.\n            this.activateFirstTab();\n        } else if (!this.tabs.find(t => t === this.activeTab)) { // O'wise check if current active tab has been deleted.\n            // If so, we must find the closest.\n            // Use `setTimeout` as this causes a 'changed after checked' error o'wise.\n            setTimeout(() => this.activateClosestTab(this.activeTab));\n        }\n\n        if (this.tabs.length === 0) {\n            // Error if there aren't any tabs in the tabset.\n            throw new Error(\"You cannot have no tabs!\");\n        }\n    }\n\n    // Fires whenever a tab header's active state is externally changed.\n    private onHeaderActiveChanged(tab:Tab):void {\n        // If the tab has become activated, but was not previously the active tab:\n        if (tab.isActive && this.activeTab !== tab) {\n            // Deactivate all of the tabs.\n            this.tabs.filter(t => t !== tab).forEach(t => t.isActive = false);\n\n            // Set the currently active tab to this one.\n            this.activeTab = tab;\n        }\n\n        // If the tab has become deactivated, but was previously the active tab:\n        if (!tab.isActive && this.activeTab === tab) {\n            // Activate the closest tab to it.\n            this.activateClosestTab(tab);\n        }\n    }\n\n    // Activate the first tab in the set.\n    public activateFirstTab():void {\n        this.activeTab = this.tabs[0];\n    }\n\n    // Activates the closest available tab to a given one.\n    public activateClosestTab(tab:Tab):void {\n        let nextAvailable:Tab | undefined;\n\n        // When the exited tab's index is higher than all available tabs,\n        if (tab.index >= this.tabs.length) {\n            // Activate the last tab.\n            nextAvailable = this.tabs[this.tabs.length - 1];\n        }\n\n        // If that didn't work, try the following cases:\n        if (!nextAvailable) {\n            if (!this.tabs.find(t => t === tab)) { // When the exited tab no longer exists,\n                // Replace it with a tab at the same index.\n                nextAvailable = this.tabs[tab.index];\n            } else { // Or if the exited tab still exists,\n                // Go to the tab immediately to the left.\n                nextAvailable = this.tabs[Math.max(tab.index - 1, 0)];\n            }\n        }\n\n        // However, if the chosen tab is disabled,\n        if (nextAvailable.isDisabled) {\n            // Activate the closest available tab to it.\n            return this.activateClosestTab(nextAvailable);\n        }\n\n        this.activeTab = nextAvailable;\n    }\n}\n"]}